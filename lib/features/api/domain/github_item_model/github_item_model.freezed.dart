// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'github_item_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

GithubItem _$GithubItemFromJson(Map<String, dynamic> json) {
  return _GithubItem.fromJson(json);
}

/// @nodoc
mixin _$GithubItem {
  String? get name => throw _privateConstructorUsedError;
  String? get path => throw _privateConstructorUsedError;
  String? get sha => throw _privateConstructorUsedError;
  int? get size => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get html_url => throw _privateConstructorUsedError;
  String? get git_url => throw _privateConstructorUsedError;
  String? get download_url => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  Links? get links => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GithubItemCopyWith<GithubItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GithubItemCopyWith<$Res> {
  factory $GithubItemCopyWith(
          GithubItem value, $Res Function(GithubItem) then) =
      _$GithubItemCopyWithImpl<$Res>;
  $Res call(
      {String? name,
      String? path,
      String? sha,
      int? size,
      String? url,
      String? html_url,
      String? git_url,
      String? download_url,
      String? type,
      Links? links});

  $LinksCopyWith<$Res>? get links;
}

/// @nodoc
class _$GithubItemCopyWithImpl<$Res> implements $GithubItemCopyWith<$Res> {
  _$GithubItemCopyWithImpl(this._value, this._then);

  final GithubItem _value;
  // ignore: unused_field
  final $Res Function(GithubItem) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? path = freezed,
    Object? sha = freezed,
    Object? size = freezed,
    Object? url = freezed,
    Object? html_url = freezed,
    Object? git_url = freezed,
    Object? download_url = freezed,
    Object? type = freezed,
    Object? links = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      sha: sha == freezed
          ? _value.sha
          : sha // ignore: cast_nullable_to_non_nullable
              as String?,
      size: size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      html_url: html_url == freezed
          ? _value.html_url
          : html_url // ignore: cast_nullable_to_non_nullable
              as String?,
      git_url: git_url == freezed
          ? _value.git_url
          : git_url // ignore: cast_nullable_to_non_nullable
              as String?,
      download_url: download_url == freezed
          ? _value.download_url
          : download_url // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      links: links == freezed
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as Links?,
    ));
  }

  @override
  $LinksCopyWith<$Res>? get links {
    if (_value.links == null) {
      return null;
    }

    return $LinksCopyWith<$Res>(_value.links!, (value) {
      return _then(_value.copyWith(links: value));
    });
  }
}

/// @nodoc
abstract class _$$_GithubItemCopyWith<$Res>
    implements $GithubItemCopyWith<$Res> {
  factory _$$_GithubItemCopyWith(
          _$_GithubItem value, $Res Function(_$_GithubItem) then) =
      __$$_GithubItemCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? name,
      String? path,
      String? sha,
      int? size,
      String? url,
      String? html_url,
      String? git_url,
      String? download_url,
      String? type,
      Links? links});

  @override
  $LinksCopyWith<$Res>? get links;
}

/// @nodoc
class __$$_GithubItemCopyWithImpl<$Res> extends _$GithubItemCopyWithImpl<$Res>
    implements _$$_GithubItemCopyWith<$Res> {
  __$$_GithubItemCopyWithImpl(
      _$_GithubItem _value, $Res Function(_$_GithubItem) _then)
      : super(_value, (v) => _then(v as _$_GithubItem));

  @override
  _$_GithubItem get _value => super._value as _$_GithubItem;

  @override
  $Res call({
    Object? name = freezed,
    Object? path = freezed,
    Object? sha = freezed,
    Object? size = freezed,
    Object? url = freezed,
    Object? html_url = freezed,
    Object? git_url = freezed,
    Object? download_url = freezed,
    Object? type = freezed,
    Object? links = freezed,
  }) {
    return _then(_$_GithubItem(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      sha: sha == freezed
          ? _value.sha
          : sha // ignore: cast_nullable_to_non_nullable
              as String?,
      size: size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      html_url: html_url == freezed
          ? _value.html_url
          : html_url // ignore: cast_nullable_to_non_nullable
              as String?,
      git_url: git_url == freezed
          ? _value.git_url
          : git_url // ignore: cast_nullable_to_non_nullable
              as String?,
      download_url: download_url == freezed
          ? _value.download_url
          : download_url // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      links: links == freezed
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as Links?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GithubItem implements _GithubItem {
  const _$_GithubItem(
      {required this.name,
      required this.path,
      required this.sha,
      required this.size,
      required this.url,
      required this.html_url,
      required this.git_url,
      required this.download_url,
      required this.type,
      required this.links});

  factory _$_GithubItem.fromJson(Map<String, dynamic> json) =>
      _$$_GithubItemFromJson(json);

  @override
  final String? name;
  @override
  final String? path;
  @override
  final String? sha;
  @override
  final int? size;
  @override
  final String? url;
  @override
  final String? html_url;
  @override
  final String? git_url;
  @override
  final String? download_url;
  @override
  final String? type;
  @override
  final Links? links;

  @override
  String toString() {
    return 'GithubItem(name: $name, path: $path, sha: $sha, size: $size, url: $url, html_url: $html_url, git_url: $git_url, download_url: $download_url, type: $type, links: $links)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GithubItem &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.path, path) &&
            const DeepCollectionEquality().equals(other.sha, sha) &&
            const DeepCollectionEquality().equals(other.size, size) &&
            const DeepCollectionEquality().equals(other.url, url) &&
            const DeepCollectionEquality().equals(other.html_url, html_url) &&
            const DeepCollectionEquality().equals(other.git_url, git_url) &&
            const DeepCollectionEquality()
                .equals(other.download_url, download_url) &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.links, links));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(path),
      const DeepCollectionEquality().hash(sha),
      const DeepCollectionEquality().hash(size),
      const DeepCollectionEquality().hash(url),
      const DeepCollectionEquality().hash(html_url),
      const DeepCollectionEquality().hash(git_url),
      const DeepCollectionEquality().hash(download_url),
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(links));

  @JsonKey(ignore: true)
  @override
  _$$_GithubItemCopyWith<_$_GithubItem> get copyWith =>
      __$$_GithubItemCopyWithImpl<_$_GithubItem>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GithubItemToJson(
      this,
    );
  }
}

abstract class _GithubItem implements GithubItem {
  const factory _GithubItem(
      {required final String? name,
      required final String? path,
      required final String? sha,
      required final int? size,
      required final String? url,
      required final String? html_url,
      required final String? git_url,
      required final String? download_url,
      required final String? type,
      required final Links? links}) = _$_GithubItem;

  factory _GithubItem.fromJson(Map<String, dynamic> json) =
      _$_GithubItem.fromJson;

  @override
  String? get name;
  @override
  String? get path;
  @override
  String? get sha;
  @override
  int? get size;
  @override
  String? get url;
  @override
  String? get html_url;
  @override
  String? get git_url;
  @override
  String? get download_url;
  @override
  String? get type;
  @override
  Links? get links;
  @override
  @JsonKey(ignore: true)
  _$$_GithubItemCopyWith<_$_GithubItem> get copyWith =>
      throw _privateConstructorUsedError;
}

Links _$LinksFromJson(Map<String, dynamic> json) {
  return _Links.fromJson(json);
}

/// @nodoc
mixin _$Links {
  String? get self => throw _privateConstructorUsedError;
  String? get git => throw _privateConstructorUsedError;
  String? get html => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LinksCopyWith<Links> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LinksCopyWith<$Res> {
  factory $LinksCopyWith(Links value, $Res Function(Links) then) =
      _$LinksCopyWithImpl<$Res>;
  $Res call({String? self, String? git, String? html});
}

/// @nodoc
class _$LinksCopyWithImpl<$Res> implements $LinksCopyWith<$Res> {
  _$LinksCopyWithImpl(this._value, this._then);

  final Links _value;
  // ignore: unused_field
  final $Res Function(Links) _then;

  @override
  $Res call({
    Object? self = freezed,
    Object? git = freezed,
    Object? html = freezed,
  }) {
    return _then(_value.copyWith(
      self: self == freezed
          ? _value.self
          : self // ignore: cast_nullable_to_non_nullable
              as String?,
      git: git == freezed
          ? _value.git
          : git // ignore: cast_nullable_to_non_nullable
              as String?,
      html: html == freezed
          ? _value.html
          : html // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_LinksCopyWith<$Res> implements $LinksCopyWith<$Res> {
  factory _$$_LinksCopyWith(_$_Links value, $Res Function(_$_Links) then) =
      __$$_LinksCopyWithImpl<$Res>;
  @override
  $Res call({String? self, String? git, String? html});
}

/// @nodoc
class __$$_LinksCopyWithImpl<$Res> extends _$LinksCopyWithImpl<$Res>
    implements _$$_LinksCopyWith<$Res> {
  __$$_LinksCopyWithImpl(_$_Links _value, $Res Function(_$_Links) _then)
      : super(_value, (v) => _then(v as _$_Links));

  @override
  _$_Links get _value => super._value as _$_Links;

  @override
  $Res call({
    Object? self = freezed,
    Object? git = freezed,
    Object? html = freezed,
  }) {
    return _then(_$_Links(
      self: self == freezed
          ? _value.self
          : self // ignore: cast_nullable_to_non_nullable
              as String?,
      git: git == freezed
          ? _value.git
          : git // ignore: cast_nullable_to_non_nullable
              as String?,
      html: html == freezed
          ? _value.html
          : html // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Links implements _Links {
  const _$_Links({required this.self, required this.git, required this.html});

  factory _$_Links.fromJson(Map<String, dynamic> json) =>
      _$$_LinksFromJson(json);

  @override
  final String? self;
  @override
  final String? git;
  @override
  final String? html;

  @override
  String toString() {
    return 'Links(self: $self, git: $git, html: $html)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Links &&
            const DeepCollectionEquality().equals(other.self, self) &&
            const DeepCollectionEquality().equals(other.git, git) &&
            const DeepCollectionEquality().equals(other.html, html));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(self),
      const DeepCollectionEquality().hash(git),
      const DeepCollectionEquality().hash(html));

  @JsonKey(ignore: true)
  @override
  _$$_LinksCopyWith<_$_Links> get copyWith =>
      __$$_LinksCopyWithImpl<_$_Links>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LinksToJson(
      this,
    );
  }
}

abstract class _Links implements Links {
  const factory _Links(
      {required final String? self,
      required final String? git,
      required final String? html}) = _$_Links;

  factory _Links.fromJson(Map<String, dynamic> json) = _$_Links.fromJson;

  @override
  String? get self;
  @override
  String? get git;
  @override
  String? get html;
  @override
  @JsonKey(ignore: true)
  _$$_LinksCopyWith<_$_Links> get copyWith =>
      throw _privateConstructorUsedError;
}
