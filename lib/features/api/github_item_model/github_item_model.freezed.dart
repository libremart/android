// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'github_item_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

GithubItemModel _$GithubItemModelFromJson(Map<String, dynamic> json) {
  return _GithubItemModel.fromJson(json);
}

/// @nodoc
mixin _$GithubItemModel {
  String? get name => throw _privateConstructorUsedError;
  String? get path => throw _privateConstructorUsedError;
  String? get sha => throw _privateConstructorUsedError;
  int? get size => throw _privateConstructorUsedError;
  String? get url => throw _privateConstructorUsedError;
  String? get htmlUrl => throw _privateConstructorUsedError;
  String? get gitUrl => throw _privateConstructorUsedError;
  String? get downloadUrl => throw _privateConstructorUsedError;
  String? get type => throw _privateConstructorUsedError;
  Links? get links => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $GithubItemModelCopyWith<GithubItemModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $GithubItemModelCopyWith<$Res> {
  factory $GithubItemModelCopyWith(
          GithubItemModel value, $Res Function(GithubItemModel) then) =
      _$GithubItemModelCopyWithImpl<$Res>;
  $Res call(
      {String? name,
      String? path,
      String? sha,
      int? size,
      String? url,
      String? htmlUrl,
      String? gitUrl,
      String? downloadUrl,
      String? type,
      Links? links});

  $LinksCopyWith<$Res>? get links;
}

/// @nodoc
class _$GithubItemModelCopyWithImpl<$Res>
    implements $GithubItemModelCopyWith<$Res> {
  _$GithubItemModelCopyWithImpl(this._value, this._then);

  final GithubItemModel _value;
  // ignore: unused_field
  final $Res Function(GithubItemModel) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? path = freezed,
    Object? sha = freezed,
    Object? size = freezed,
    Object? url = freezed,
    Object? htmlUrl = freezed,
    Object? gitUrl = freezed,
    Object? downloadUrl = freezed,
    Object? type = freezed,
    Object? links = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      sha: sha == freezed
          ? _value.sha
          : sha // ignore: cast_nullable_to_non_nullable
              as String?,
      size: size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      htmlUrl: htmlUrl == freezed
          ? _value.htmlUrl
          : htmlUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      gitUrl: gitUrl == freezed
          ? _value.gitUrl
          : gitUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      downloadUrl: downloadUrl == freezed
          ? _value.downloadUrl
          : downloadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      links: links == freezed
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as Links?,
    ));
  }

  @override
  $LinksCopyWith<$Res>? get links {
    if (_value.links == null) {
      return null;
    }

    return $LinksCopyWith<$Res>(_value.links!, (value) {
      return _then(_value.copyWith(links: value));
    });
  }
}

/// @nodoc
abstract class _$$_GithubItemModelCopyWith<$Res>
    implements $GithubItemModelCopyWith<$Res> {
  factory _$$_GithubItemModelCopyWith(
          _$_GithubItemModel value, $Res Function(_$_GithubItemModel) then) =
      __$$_GithubItemModelCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? name,
      String? path,
      String? sha,
      int? size,
      String? url,
      String? htmlUrl,
      String? gitUrl,
      String? downloadUrl,
      String? type,
      Links? links});

  @override
  $LinksCopyWith<$Res>? get links;
}

/// @nodoc
class __$$_GithubItemModelCopyWithImpl<$Res>
    extends _$GithubItemModelCopyWithImpl<$Res>
    implements _$$_GithubItemModelCopyWith<$Res> {
  __$$_GithubItemModelCopyWithImpl(
      _$_GithubItemModel _value, $Res Function(_$_GithubItemModel) _then)
      : super(_value, (v) => _then(v as _$_GithubItemModel));

  @override
  _$_GithubItemModel get _value => super._value as _$_GithubItemModel;

  @override
  $Res call({
    Object? name = freezed,
    Object? path = freezed,
    Object? sha = freezed,
    Object? size = freezed,
    Object? url = freezed,
    Object? htmlUrl = freezed,
    Object? gitUrl = freezed,
    Object? downloadUrl = freezed,
    Object? type = freezed,
    Object? links = freezed,
  }) {
    return _then(_$_GithubItemModel(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      path: path == freezed
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String?,
      sha: sha == freezed
          ? _value.sha
          : sha // ignore: cast_nullable_to_non_nullable
              as String?,
      size: size == freezed
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int?,
      url: url == freezed
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String?,
      htmlUrl: htmlUrl == freezed
          ? _value.htmlUrl
          : htmlUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      gitUrl: gitUrl == freezed
          ? _value.gitUrl
          : gitUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      downloadUrl: downloadUrl == freezed
          ? _value.downloadUrl
          : downloadUrl // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as String?,
      links: links == freezed
          ? _value.links
          : links // ignore: cast_nullable_to_non_nullable
              as Links?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_GithubItemModel implements _GithubItemModel {
  const _$_GithubItemModel(
      {required this.name,
      required this.path,
      required this.sha,
      required this.size,
      required this.url,
      required this.htmlUrl,
      required this.gitUrl,
      required this.downloadUrl,
      required this.type,
      required this.links});

  factory _$_GithubItemModel.fromJson(Map<String, dynamic> json) =>
      _$$_GithubItemModelFromJson(json);

  @override
  final String? name;
  @override
  final String? path;
  @override
  final String? sha;
  @override
  final int? size;
  @override
  final String? url;
  @override
  final String? htmlUrl;
  @override
  final String? gitUrl;
  @override
  final String? downloadUrl;
  @override
  final String? type;
  @override
  final Links? links;

  @override
  String toString() {
    return 'GithubItemModel(name: $name, path: $path, sha: $sha, size: $size, url: $url, htmlUrl: $htmlUrl, gitUrl: $gitUrl, downloadUrl: $downloadUrl, type: $type, links: $links)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_GithubItemModel &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.path, path) &&
            const DeepCollectionEquality().equals(other.sha, sha) &&
            const DeepCollectionEquality().equals(other.size, size) &&
            const DeepCollectionEquality().equals(other.url, url) &&
            const DeepCollectionEquality().equals(other.htmlUrl, htmlUrl) &&
            const DeepCollectionEquality().equals(other.gitUrl, gitUrl) &&
            const DeepCollectionEquality()
                .equals(other.downloadUrl, downloadUrl) &&
            const DeepCollectionEquality().equals(other.type, type) &&
            const DeepCollectionEquality().equals(other.links, links));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(path),
      const DeepCollectionEquality().hash(sha),
      const DeepCollectionEquality().hash(size),
      const DeepCollectionEquality().hash(url),
      const DeepCollectionEquality().hash(htmlUrl),
      const DeepCollectionEquality().hash(gitUrl),
      const DeepCollectionEquality().hash(downloadUrl),
      const DeepCollectionEquality().hash(type),
      const DeepCollectionEquality().hash(links));

  @JsonKey(ignore: true)
  @override
  _$$_GithubItemModelCopyWith<_$_GithubItemModel> get copyWith =>
      __$$_GithubItemModelCopyWithImpl<_$_GithubItemModel>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_GithubItemModelToJson(
      this,
    );
  }
}

abstract class _GithubItemModel implements GithubItemModel {
  const factory _GithubItemModel(
      {required final String? name,
      required final String? path,
      required final String? sha,
      required final int? size,
      required final String? url,
      required final String? htmlUrl,
      required final String? gitUrl,
      required final String? downloadUrl,
      required final String? type,
      required final Links? links}) = _$_GithubItemModel;

  factory _GithubItemModel.fromJson(Map<String, dynamic> json) =
      _$_GithubItemModel.fromJson;

  @override
  String? get name;
  @override
  String? get path;
  @override
  String? get sha;
  @override
  int? get size;
  @override
  String? get url;
  @override
  String? get htmlUrl;
  @override
  String? get gitUrl;
  @override
  String? get downloadUrl;
  @override
  String? get type;
  @override
  Links? get links;
  @override
  @JsonKey(ignore: true)
  _$$_GithubItemModelCopyWith<_$_GithubItemModel> get copyWith =>
      throw _privateConstructorUsedError;
}

Links _$LinksFromJson(Map<String, dynamic> json) {
  return _Links.fromJson(json);
}

/// @nodoc
mixin _$Links {
  String? get self => throw _privateConstructorUsedError;
  String? get git => throw _privateConstructorUsedError;
  String? get html => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $LinksCopyWith<Links> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LinksCopyWith<$Res> {
  factory $LinksCopyWith(Links value, $Res Function(Links) then) =
      _$LinksCopyWithImpl<$Res>;
  $Res call({String? self, String? git, String? html});
}

/// @nodoc
class _$LinksCopyWithImpl<$Res> implements $LinksCopyWith<$Res> {
  _$LinksCopyWithImpl(this._value, this._then);

  final Links _value;
  // ignore: unused_field
  final $Res Function(Links) _then;

  @override
  $Res call({
    Object? self = freezed,
    Object? git = freezed,
    Object? html = freezed,
  }) {
    return _then(_value.copyWith(
      self: self == freezed
          ? _value.self
          : self // ignore: cast_nullable_to_non_nullable
              as String?,
      git: git == freezed
          ? _value.git
          : git // ignore: cast_nullable_to_non_nullable
              as String?,
      html: html == freezed
          ? _value.html
          : html // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$$_LinksCopyWith<$Res> implements $LinksCopyWith<$Res> {
  factory _$$_LinksCopyWith(_$_Links value, $Res Function(_$_Links) then) =
      __$$_LinksCopyWithImpl<$Res>;
  @override
  $Res call({String? self, String? git, String? html});
}

/// @nodoc
class __$$_LinksCopyWithImpl<$Res> extends _$LinksCopyWithImpl<$Res>
    implements _$$_LinksCopyWith<$Res> {
  __$$_LinksCopyWithImpl(_$_Links _value, $Res Function(_$_Links) _then)
      : super(_value, (v) => _then(v as _$_Links));

  @override
  _$_Links get _value => super._value as _$_Links;

  @override
  $Res call({
    Object? self = freezed,
    Object? git = freezed,
    Object? html = freezed,
  }) {
    return _then(_$_Links(
      self: self == freezed
          ? _value.self
          : self // ignore: cast_nullable_to_non_nullable
              as String?,
      git: git == freezed
          ? _value.git
          : git // ignore: cast_nullable_to_non_nullable
              as String?,
      html: html == freezed
          ? _value.html
          : html // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_Links implements _Links {
  const _$_Links({required this.self, required this.git, required this.html});

  factory _$_Links.fromJson(Map<String, dynamic> json) =>
      _$$_LinksFromJson(json);

  @override
  final String? self;
  @override
  final String? git;
  @override
  final String? html;

  @override
  String toString() {
    return 'Links(self: $self, git: $git, html: $html)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_Links &&
            const DeepCollectionEquality().equals(other.self, self) &&
            const DeepCollectionEquality().equals(other.git, git) &&
            const DeepCollectionEquality().equals(other.html, html));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(self),
      const DeepCollectionEquality().hash(git),
      const DeepCollectionEquality().hash(html));

  @JsonKey(ignore: true)
  @override
  _$$_LinksCopyWith<_$_Links> get copyWith =>
      __$$_LinksCopyWithImpl<_$_Links>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_LinksToJson(
      this,
    );
  }
}

abstract class _Links implements Links {
  const factory _Links(
      {required final String? self,
      required final String? git,
      required final String? html}) = _$_Links;

  factory _Links.fromJson(Map<String, dynamic> json) = _$_Links.fromJson;

  @override
  String? get self;
  @override
  String? get git;
  @override
  String? get html;
  @override
  @JsonKey(ignore: true)
  _$$_LinksCopyWith<_$_Links> get copyWith =>
      throw _privateConstructorUsedError;
}
